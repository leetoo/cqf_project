package com.luigisgro.cqf.fdm;

import java.util.ArrayList;
import java.util.List;


/**
 * High level class representing a trading strategy with static hedging.
 * It is also the access point to run the FDM pricing when used with
 * portfolios with static hedge.
 * @author Luigi Sgro
 *
 */
public class StaticHedgingStrategy {
	private Grid grid;
	private Portfolio portfolio;
	private FiniteDifferenceModel method;
	private double r;
	private boolean printProgress;
	private Portfolio.Item[] hedgeItems;
	
	/**
	 * Creates a new static hedging strategy object
	 * @param grid The grid for FDM
	 * @param portfolio The portfolio
	 * @param method The Finite Difference method to be used
	 * @param r The interest rate
	 */
	public StaticHedgingStrategy(Grid grid, Portfolio portfolio, FiniteDifferenceModel method, double r) {
		this.grid = grid;
		this.portfolio = portfolio;
		this.method = method;
		this.r = r;
		List<Portfolio.Item> hedgeItemList = new ArrayList<Portfolio.Item>();
		for (Portfolio.Item item : portfolio.getItems().values()) {
			if (item.isHedge) {
				hedgeItemList.add(item);
			}
		}
		hedgeItems = hedgeItemList.toArray(new Portfolio.Item[hedgeItemList.size()]);
	}

	/**
	 * Accessor method for the printProgress parameter
	 * @return True if the print of progress is enabled, false otherwise
	 */
	public boolean isPrintProgress() {
		return printProgress;
	}

	/**
	 * Set the print progress
	 * @param printProgress True to enable it, false to disable it
	 */
	public void setPrintProgress(boolean printProgress) {
		this.printProgress = printProgress;
	}
	
	/**
	 * Returns the array of items tagged as hedging instrument, together with their current position
	 * @return An array of {@link Portfolio.Item}
	 */
	public Portfolio.Item[] getHedgeItems() {
		return hedgeItems;
	}
	
	/**
	 * The portfolio managed by the strategy
	 * @return The internal {@link Portfolio} object
	 */
	public Portfolio getPortfolio() {
		return portfolio;
	}

	/**
	 * Calculates the cost of the portfolio, typically corresponding to the cost of the hedge
	 * by multiplying the unit cost to the position
	 * @return The current cost of the instrument with a price
	 */
	public double cost() {
		double cost = 0;
		for (Portfolio.Item item : portfolio.getItems().values()) {
			cost += item.position * item.unitPrice;
		}
		return cost;
	}
	
	/**
	 * The present value of the portfolio at stock = s
	 * @param s The stock value to be used
	 * @return The value of the portfolio at s
	 */
	public double getValueAt(double s) {
		return grid.getPresentInterpolated(s);
	}
	
	/**
	 * Calculates the difference between the overall value of the portfolio according to
	 * FDM and the cost of hedging at a specific value of the stock
	 * @param s The value of stock
	 * @return The P&L generated by this trading strategy at s. If the derivative to be
	 * priced has cost = 0, this correspond to the calculated value of the derivative
	 */
	public double getPnLAt(double s) {
		return getValueAt(s) - cost();
	}
	
	/**
	 * Run the FDM to evaluate the portfolio
	 * @return True if the pricing succeeded, false otherwise
	 */
	public boolean runPricing() {
		return FiniteDifferencePricer.evaluate(grid, portfolio, method, r, printProgress, null);
	}

	/**
	 * Returns an array containing the position of each hedging instrument, in the same
	 * order as they have been added to the strategy
	 * @return An array of hedging instrument positions
	 */
	public double[] hedgePositions() {
		double positions[] = new double[getHedgeItems().length];
		for (int i = 0; i < getHedgeItems().length; i++)
			positions[i]= getHedgeItems()[i].position;
		return positions;
	}

	/**
	 * Utility method to allow a pretty print 
	 * @return A string representing the current position of the hedge instruments
	 */
	public String hedgePositionsDesc() {
		String desc = "[ ";
		for (Portfolio.Item item : getHedgeItems())
			desc += item.position + " ";
		desc += "]";
		return desc;
	}
}
