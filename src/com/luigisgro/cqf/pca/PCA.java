package com.luigisgro.cqf.pca;

import com.luigisgro.cqf.curve.Curve;
import com.luigisgro.cqf.curve.CurveTimeSeries;
import com.luigisgro.cqf.curve.TimePoint;
import com.luigisgro.cqf.linalg.Matrix;
import com.luigisgro.cqf.linalg.Vector;

/**
 * The top-level class implementing PCA on the covariance matrix of a curve time series
 * @author Luigi Sgro
 *
 * @param <T>
 */
public class PCA<T extends TimePoint> {
	public static final double DEFAULT_DIAGONALIZATION_TOLERANCE = 1E-12;
	public static final int DEFAULT_MAX_DIAGONALIZATION_ITERATIONS = 1000;
	
	private CurveTimeSeries<T> timeSeries;
	private Curve[] principalComponents;
	private Vector componentEigenvalues;
	private Matrix componentEigenvectors;
	private double diagonalizationTolerance = DEFAULT_DIAGONALIZATION_TOLERANCE;
	private int maxDiagonalizationInteractions = DEFAULT_MAX_DIAGONALIZATION_ITERATIONS;
	
	/**
	 * The {@link com.luigisgro.cqf.curve.CurveTimeSeries} to be processed
	 * @param timeSeries
	 */
	public PCA(CurveTimeSeries<T> timeSeries) {
		this.timeSeries = timeSeries;
	}
	
	/**
	 * The maximum error for the non-diagonal element to be used for iterative diagonalization
	 * @return Maximum value out of diagonal
	 */
	public double getDiagonalizationTolerance() {
		return diagonalizationTolerance;
	}

	/**
	 * 
	 * @param diagonalizationTolerance The maximum error for the non-diagonal element to be used
	 * for iterative diagonalization
	 */
	public void setDiagonalizationTolerance(double diagonalizationTolerance) {
		this.diagonalizationTolerance = diagonalizationTolerance;
	}
	
	/**
	 * Utility method returns the amount of variance depending on the number of factors
	 * @param order The number of factors to be used
	 * @return The ratio between the variance generated by the first order factors and the total variance
	 */
	public double cumulativeRatioOfVariance(int order) {
		double tmpSum = 0;
		for (int i = 0; i < order; i++) {
			tmpSum += componentEigenvalues.get(i);
		}
		return tmpSum / Vector.sumOfElements(componentEigenvalues);
	}

	/**
	 * Returns the order-th eigenvector of the covariance matrix, in form of a {@link com.luigisgro.cqf.curve.Curve}
	 * @param order The index of the component
	 * @return The order-th principal component
	 */
	public Curve getPrincipalComponent(int order) {
		return principalComponents[order];
	}
	
	/**
	 * Performs the PCA processing
	 * @return The number of iteration performed in the diagonalization of the covariance matrix
	 */
	public int process() {
		CurveTimeSeriesMatrixAdapter<T> timeSeriesMatrix = new CurveTimeSeriesMatrixAdapter<T>(timeSeries);
		Matrix increments = Matrix.rowDifference(timeSeriesMatrix);
		Matrix cov = Matrix.columnCovariance(increments);
		cov = cov.scale(1.0 / timeSeries.getTimeStep()); // total period variance
		JacobiDiagonalization jd = new JacobiDiagonalization(cov, diagonalizationTolerance);
		int numIterations = jd.process(maxDiagonalizationInteractions);
		jd.sortEigenvaluesDesc();
		componentEigenvalues = jd.getEigenvalues();
		componentEigenvectors = jd.getEigenvectors();
		principalComponents = new Curve[componentEigenvectors.numOfColumns()];
		for (int i = 0; i < componentEigenvectors.numOfColumns(); i++) {
			principalComponents[i] = new Curve(componentEigenvectors.getColumn(i).toDoubleArray(), timeSeries.getTermStructure());
		}
		return numIterations;
	}

	/**
	 * The eigenvalues sorted in a descending order
	 * @return A Vector of eigenvalues
	 */
	public Vector getComponentEigenvalues() {
		return componentEigenvalues;
	}

	/**
	 * The eigenvectors sorted in descending order of the corresponding eigenvalues
	 * @return A Matrix with all the eigenvectors as columns
	 */
	public Matrix getComponentEigenvectors() {
		return componentEigenvectors;
	}

}
